library(snpStats)
library(Matrix)
library(corpcor)
library(mvtnorm)

## Code to sample multivariate norm
#' \code{mvs_perm} sample from a multivariate normal distribution
#' @param m a vector -  mean values
#' @param sigma a matrix  - a positive definite covariance matrix
#' @param n a scalar - number of samples to generate (default 2)
#' @return a matrix of sampled values

mvs_perm<-function(m,sigma,n=2){
  if(!is.matrix(sigma))
    stop("sigma parameter is not a matrix")
  if(!is.positive.definite(sigma,,method="chol"))
    stop("sigma is not positive definite")
  rd<-rmvnorm(n,mean=m,sigma=sigma,method="chol")
  t(rd)
}

## Code to compute sigma - genotype covariance matrix
#' \code{mvs_sigma} create a geneotype convariance matrix
#' @param r a matrix of pairwise \eqn{r^2} measures generated by snpStats
#' @return a positive definite approximation of covariance matrix

mvs_sigma<-function(r){
  diag(r)<-1
  if(any(is.na(r)))
    message(sprintf("Found %s where r was na",sum(is.na(r))))
    r[is.na(r)]<-0
  return(as(make.positive.definite(r),"Matrix"))
}

#' convert a vcf file to snpMatrix object
#' \code{vcf2snpmatrix} convert a vcf file to snpMatrix object
#'
#' @param vcf a scalar - path to vcf file
#' @param bcf_tools a scalar - path to bcftools binary
#' @param region_file a scalar - path to a file satisfying -R bcftools criteria (optional)
#' @param quiet a boolean - if set to false then debug information shown (default = FALSE)
#' @return a list with two slots. sm is the snpMatrix object and info is a data.table describes SNPs
#' @export

vcf2snpmatrix <- function(vcf,bcf_tools,region_file,quiet=TRUE){
  header_cmd <- sprintf("%s view -h %s",bcft,vcf.file)
  if(!quiet)
    message(header_cmd)
  my.pipe<-pipe(header_cmd)
  header<-tail(scan(my.pipe,what=character(),sep="\n",quiet=TRUE),n=1)
  close(my.pipe)
  cnames<-unlist(strsplit(header,"\t"))
  if(!missing(region_file)){
    vcftools_cmd<-sprintf("%s view -R %s -O v %s | grep -v '^#'",bcft,region_file ,vcf.file)
  }else{
    vcftools_cmd<-sprintf("%s view -O v %s | grep -v '^#'",bcft,vcf.file)
  }
  if(!quiet)
    message(vcftools_cmd)
  tmp<-fread(vcftools_cmd)
  setnames(tmp,cnames)
  gt<-tmp[,10:ncol(tmp),with=FALSE]
  if(nrow(gt)==0)
    return(NA)
  info<-tmp[,1:9,with=FALSE]
  setnames(info,'#CHROM','CHROM')
  if(!quiet)
    message("Creating snpMatrix obj")
  sm<-apply(gt,1,function(x) sub("0\\|0","1",x))
  sm<-apply(sm,1,function(x) sub("(0\\|1)|(1\\|0)","2",x))
  sm<-apply(sm,1,function(x) sub("1\\|1","3",x))
  ## set anything else to a missing value
  sm<-t(apply(sm,1,function(x) as.raw(sub("[0-9]\\|[0-9]","0",x))))
  info[,pid:=paste(CHROM,POS,sep=':')]
  colnames(sm)<-info$pid
  rownames(sm)<-colnames(gt)
  return(list(sm=new("SnpMatrix", sm),info=info))
}


simulate_beta <- function(sm,lor,se_lor,lor_shrink=1,n_sims=1){
  beta_hat<-lor * lor_shrink
  if(length(lor)==1)
    return(t(rnorm(n.sims,mean=beta_hat,sd=se_lor)))
  # compute R statistic
  r<-ld(sm,sm,stats="R")
  # compute closest pos-def covariance matrix
  r<-as.matrix(mvs_sigma(Matrix(r)))
  ## for beta the covariance matrix is estimates by sigma x SE * SE^T
  cov_se<-tcrossprod(se_lor)
  cov.beta<-cov_se * r
  ## simulate beta
  return(mvs_perm(beta_hat,cov.beta,n=n.sims))
}
